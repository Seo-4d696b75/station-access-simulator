import { writeFile } from "fs/promises"
import { join } from "path"
import { TypescriptParser, VariableDeclaration } from "typescript-parser"

interface Target {
  type: string
  importName: string
}

async function generate(dir: string) {
  const parser = new TypescriptParser()
  const file = await parser.parseFile(join(dir, "schema.ts"), "root")
  const declarations = file.declarations

  // grep schema for copy & merge function
  const schemes = declarations
    .filter((d): d is VariableDeclaration => d instanceof VariableDeclaration)
    .filter(d => d.isExported)
    .map(d => {
      const m = d.name.match(/^(?<name>\w+)Schema$/)
      const name = m?.groups?.["name"]
      return name ? {
        importName: d.name,
        type: `${name[0].toUpperCase()}${name.slice(1)}`
      } : undefined
    })
    .filter((d): d is Target => d !== undefined)

  console.log(`${schemes.length} schema found.`)

  // generate index.ts
  let str = `import * as types from '../';\n`
  str += "import { ReadonlyState } from '../core/state';\n\n"
  str += "import { createCopyFunc, createMergeFunc } from './helper';\n"
  str += "import * as schema from './schema';\n"
  str += "/*\n"
  str += " * This file is auto-generated by ./generate.ts\n"
  str += " * Reading schemes and custom functions exported in ./schema.ts,\n"
  str += " * the generator defines copy & merge functions for each type.\n"
  str += " * Unlink cloneDeep and merge function provided by lodash,\n"
  str += " * these functions ONLY copy or merge properties defined in each type declaration.\n"
  str += " * But not much as powerful as lodash, so only plane object supported.\n"
  str += " * \n"
  str += " * The generator searches ./schema.ts for\n"
  str += " * variable named '${name}Schema', where its type must be ObjectSchema<$name>,\n"
  str += " * then generates copy & merge functions\n"
  str += " */\n\n"

  str += "// auto generated copy functions from schema and custom function exported in ./schema.ts\n"
  str += "export namespace copy {\n"
  str += "  // from schema\n"
  str += schemes.map(t => `  export const ${t.type}: (src: ReadonlyState<types.${t.type}>) => types.${t.type} = createCopyFunc(schema.${t.importName})`).join("\n")
  str += "\n}\n\n"

  str += "// auto generated merge functions from schema and custom function exported in ./schema.ts\n"
  str += "export namespace merge {\n"
  str += "  // from schema\n"
  str += schemes.map(t => `  export const ${t.type}: (dst: types.${t.type}, src: ReadonlyState<types.${t.type}>) => void = createMergeFunc(schema.${t.importName})`).join("\n")
  str += "\n}\n"

  await writeFile(join(dir, "index.ts"), str)

  // generate matcher.ts
  str = `import * as types from '../';\n`
  str += "import { createMatcher } from './helper';\n"
  str += "import * as schema from './schema';\n"
  str += "/*\n"
  str += " * This file is auto-generated by ./generate.ts\n"
  str += " * Reading schemes and custom functions exported in ./schema.ts,\n"
  str += " * the generator defines custom jest matcher for each type.\n"
  str += " * Unlink toMatchObject provided by default,\n"
  str += " * these custom matchers ONLY compare properties defined in each type declaration.\n"
  str += " * \n"
  str += " * The generator searches ./schema.ts for\n"
  str += " * variable named '${name}Schema', where its type must be ObjectSchema<$name>,\n"
  str += " * then generates custom matchers\n"
  str += " */\n\n"

  str += "// auto generated matchers\n"
  str += schemes.map(t => `export const toMatch${t.type} = createMatcher<types.${t.type}>(schema.${t.importName})`).join("\n")
  str += "\n\n"

  str += "// declare types for custom matchers\n"
  str += "declare global {\n"
  str += "  namespace jest {\n"
  str += "    interface Matchers<R> {\n"
  str += schemes.map(t => `      toMatch${t.type}(expected: types.${t.type}, ...mergeWithExpected: any[]): R;`).join("\n")
  str += "\n    }\n\n"
  str += "    interface Expect {\n"
  str += schemes.map(t => `      toMatch${t.type}: (expected: types.${t.type}, ...mergeWithExpected: any[]) => any;`).join("\n")
  str += "\n    }\n\n"
  str += "    interface InverseAsymmetricMatchers {\n"
  str += schemes.map(t => `      toMatch${t.type}: (expected: types.${t.type}, ...mergeWithExpected: any[]) => any;`).join("\n")
  str += "\n    }\n"
  str += "  }\n"
  str += "}\n\n"

  str += "// register custom matchers\n"
  str += "expect.extend({\n"
  str += schemes.map(t => `  toMatch${t.type}`).join(",\n")
  str += "\n})\n"

  await writeFile(join(dir, "matcher.ts"), str)

  console.log("code generated!")
}

generate(__dirname)